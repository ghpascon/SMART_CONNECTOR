{# TAGS TABLE #}
<div
  class="table-wrapper shadow"
  style="
    margin-top: 5px;
    max-height: 60vh;
    overflow-y: auto;
    border: 3px solid #000;
    border-radius: 5px;
  "
>
  <table
    class="table table-striped"
    style="border-collapse: collapse; margin-bottom: 0; width: 100%"
  >
    <thead
      class="table-dark sticky-top"
      style="
        font-weight: bold;
        font-size: 1.2rem;
        width: 100%;
        table-layout: fixed;
      "
    >
      <tr id="tags-header">
        <!-- Dynamic header with filters -->
      </tr>
    </thead>
    <tbody
      id="tags-body"
      style="
        font-weight: bold;
        font-size: 1rem;
        max-height: calc(60vh - 50px);
        overflow-y: auto;
        width: 100%;
      "
    >
      <!-- Dynamic body -->
    </tbody>
  </table>
</div>

<script>
  // Update tags and events every 500ms
  function att_table() {
    fetchTags();
  }

  att_table();
  setInterval(att_table, 500);

  // Global state
  let tagsFilters = {};
  let tagsData = [];
  let tagsColumns = [];
  let isTypingFilter = false;
  let isFetchingTags = false;

  function formatTimestamp(value, key) {
    if (!value) return value;

    if (key === "timestamp") {
      const d = new Date(value);
      if (!isNaN(d)) {
        const h = String(d.getHours()).padStart(2, "0");
        const m = String(d.getMinutes()).padStart(2, "0");
        const s = String(d.getSeconds()).padStart(2, "0");
        return `${h}:${m}:${s}`;
      }
    }

    return value;
  }

  // Render body with filters
  function renderTagsBody(data) {
    const tbody = document.getElementById("tags-body");
    if (!tbody) return;

    const tableEl = document.getElementById("tags-header")?.closest("table");
    const wrapper = tableEl ? tableEl.closest(".table-wrapper") : null;
    const prevScrollTop = wrapper ? wrapper.scrollTop : 0;

    tbody.innerHTML = "";

    const active = Object.entries(tagsFilters).filter(
      ([, v]) => v && String(v).trim() !== ""
    );

    const filtered = active.length
      ? data.filter((item) =>
          active.every(([key, query]) =>
            String(item[key] ?? "")
              .toLowerCase()
              .includes(String(query).toLowerCase())
          )
        )
      : data;

    if (filtered.length === 0) {
      const row = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = tagsColumns.length || 1;
      td.className = "text-center bold";
      td.textContent = "Waiting for tags...";
      row.appendChild(td);
      tbody.appendChild(row);
    } else {
      filtered.forEach((item) => {
        const row = document.createElement("tr");

        row.innerHTML = Object.entries(item)
          .map(([key, value]) => `<td>${formatTimestamp(value, key)}</td>`)
          .join("");

        tbody.appendChild(row);
      });
    }

    if (wrapper) wrapper.scrollTop = prevScrollTop;
  }

  async function fetchTags() {
    if (isFetchingTags) return;
    isFetchingTags = true;
    try {
      {# const response = await fetch("{{ url_for('get_gtin_count') }}"); #}

      const response = await fetch("{{ url_for('get_tags') }}");
      const data = await response.json();

      tagsData = Array.isArray(data) ? data : [];

      if (isTypingFilter) return;

      const header = document.getElementById("tags-header");
      const newKeys = tagsData.length ? Object.keys(tagsData[0]) : [];
      const keysChanged =
        newKeys.length !== tagsColumns.length ||
        newKeys.some((k, i) => k !== tagsColumns[i]);

      if (keysChanged) {
        header.innerHTML = "";
        newKeys.forEach((key, idx) => {
          const th = document.createElement("th");

          // Column title
          const title = document.createElement("div");
          title.textContent = key.charAt(0).toUpperCase() + key.slice(1);
          th.appendChild(title);

          // Filter input
          const wrapper = document.createElement("div");
          wrapper.style.display = "flex";
          wrapper.style.alignItems = "center";

          const input = document.createElement("input");
          input.type = "text";
          input.className = "form-control form-control-sm";
          input.placeholder = "Filter";
          input.value = tagsFilters[key] || "";

          input.addEventListener("focus", () => {
            isTypingFilter = true;
          });
          input.addEventListener("blur", () => {
            isTypingFilter = false;
            renderTagsBody(tagsData);
          });
          input.addEventListener("input", (e) => {
            tagsFilters[key] = e.target.value;
            renderTagsBody(tagsData);
          });

          wrapper.appendChild(input);

          // Clear button only in the last column
          if (idx === newKeys.length - 1) {
            const clearBtn = document.createElement("button");
            clearBtn.type = "button";
            clearBtn.textContent = "Clear";
            clearBtn.className = "btn btn-sm btn-secondary ms-2";
            clearBtn.addEventListener("click", () => {
              tagsFilters = {};
              header
                .querySelectorAll("input")
                .forEach((inp) => (inp.value = ""));
              renderTagsBody(tagsData);
            });
            wrapper.appendChild(clearBtn);
          }

          th.appendChild(wrapper);
          header.appendChild(th);
        });

        tagsColumns = newKeys;
      }

      if (!isTypingFilter) renderTagsBody(tagsData);
    } catch (error) {
      console.error("Error fetching tags:", error);
    } finally {
      isFetchingTags = false;
    }
  }
</script>
